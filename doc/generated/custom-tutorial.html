<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.2.8: http://docutils.sourceforge.net/" />
<title>Custom Event Handler Tutorial</title>
<meta name="author" content="Pete Kazmier" />
<link rel="stylesheet" href="http://www.kazmier.com/computer/logwrap/docutils.css" type="text/css" />
</head>
<body>
<div class="document" id="custom-event-handler-tutorial">
<h1 class="title">Custom Event Handler Tutorial</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Pete Kazmier</td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>custom-tutorial.txt,v 1.2 2003/08/01 19:13:53 kaz Exp</td></tr>
</tbody>
</table>
<div class="section" id="introduction">
<h1><a name="introduction">Introduction</a></h1>
<p>The standard LogWrap distribution comes with a handful of event
handlers that can be used to process events which are generated by
matching lines in a log file.  These event handlers can do the
following: printing of messages to a file, email generation, SNMP Trap
notifications, as well as some suppression handlers.  If these event
handlers are not sufficient or do not meet your requirements, you can
provide your own custom event handlers.  It is this topic that will be
explored in this tutorial.</p>
</div>
<div class="section" id="overview">
<h1><a name="overview">Overview</a></h1>
<p>In this tutorial, you will learn how to create and use your own custom
event handler using the <tt class="literal"><span class="pre">logwrap</span></tt> program and its XML configuration
file.  Lets assume for this tutorial that you are going to require an
event handler that can telnet to a host and execute a command when
certain messages arrive in your log file (<tt class="literal"><span class="pre">/var/log/app.log</span></tt>).
Specifically, when a line in the following form:</p>
<pre class="literal-block">
WARNING: Disk Space Low on 10.11.12.13
</pre>
<p>Upon receipt of this message, you want to telnet to the host
identified in the message, 10.11.12.13, and then issue a <tt class="literal"><span class="pre">df</span></tt>
command to display the amount of free disk space on the host (this
tutorial assumes the hosts are UNIX-based).  To avoid flooding the
host with telnet requests, you will also limit the frequency your
custom event handler is triggered.  In this example, the event handler
will only be executed if a message for the <em>same</em> host is received 3
or more times within a 10-second interval.</p>
<p>You are now ready to proceed in the implementation of your own custom
event handler.  The next section will discuss the XML configuration
file that drives the <tt class="literal"><span class="pre">logwrap</span></tt> program by specifying sets of rules
and their associated event handlers that should be executed upon a
successful match.  Following that section, the custom event handler is
implemented in a simple Python script that <tt class="literal"><span class="pre">logwrap</span></tt> will use to
load the event handler.</p>
</div>
<div class="section" id="xml-configuration">
<h1><a name="xml-configuration">XML Configuration</a></h1>
<p>The XML configuration file specifies which log files are to be
monitored, the patterns that are to be matched, and the event handlers
used to process each match.  The following is a trivial configuration
file that contains a single rule that matches lines in the format
described earlier as well as the event handlers used to process that
log message:</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;

&lt;logWrap&gt;
  &lt;handlerDirectory dir=&quot;/home/kaz/src&quot;/&gt;

  &lt;logEncapsulator name=&quot;Tutorial Encapsulator&quot;&gt;
    &lt;logFile file=&quot;/var/log/app.log&quot;/&gt;

    &lt;rule&gt;
      &lt;regexp&gt;WARNING: Disk Space Low on (\d+\.\d+\.\d+\.\d+)&lt;/regexp&gt;

      &lt;handler type=&quot;Frequency&quot; threshold=&quot;3&quot; interval=&quot;10&quot; match_on=&quot;1&quot;/&gt;
      &lt;handler type=&quot;CustomEventHandlers:TelnetHost&quot;
               host=&quot;\1&quot;
               user=&quot;kaz&quot;
               password=&quot;blahblah&quot;
               command=&quot;df&quot;/&gt;
    &lt;/rule&gt;

  &lt;/logEncapsulator&gt;
&lt;/logWrap&gt;
</pre>
<p>The above configuration file should be familiar to you (with the
exception of our new event handler definition).  If this is not the
case, it is recommended that you read the sample XML <a
    class="reference" href="logwrap.txt">configuration</a>
file that comes with the distribution because every feature is
documented.</p>
<p>There are a few items of interest.  First, the <tt class="literal"><span class="pre">&lt;handlerDirectory&gt;</span></tt>
specifies a directory where you'll put your custom event handlers
(more on that later).  Next, a single encapsulator is defined to
monitor the <tt class="literal"><span class="pre">/var/log/app.log</span></tt> file.  This encapsulator contains a
single rule that matches any lines matching the specified
<tt class="literal"><span class="pre">&lt;regexp&gt;</span></tt>.  Not only does it match the regular expression, but the
grouping operators (the parentheses) are used to group the IP address
that is part of the log entry.  For example:</p>
<pre class="literal-block">
WARNING: Disk Space Low on 10.11.12.13
</pre>
<p>The IP address, <tt class="literal"><span class="pre">10.11.12.13</span></tt>, will be &quot;saved&quot; for use later.  By
using the grouping operators, event handlers have the opportunity to
inspect and use the items that have been grouped.  As you'll see
later, both of the specified event handlers will utilize this
information in one manner or the other.</p>
<p>The next set of elements in the configuration is a series of event
handlers which are executed in the specified order.  This is called an
event handler chain.  Any of the event handlers may terminate the
chain if desired.  This is how the Frequency handler operates.  When
it is invoked, it will terminate the event chain unless 3 log messages
have occurred in 10 seconds containing the <em>same</em> IP address.  The
same IP address is matched because of the <tt class="literal"><span class="pre">match_on</span></tt> attribute,
which specifies a comma-separated list of numbers.  These numbers are
positional parameters indicating one of the groups that were saved
from the regular expression.</p>
<p>Finally, if the appropriate number of messages arrive in the given
interval, the custom event handler called <tt class="literal"><span class="pre">TelnetHost</span></tt> is executed.
A custom event handler's type is specified in the following manner:</p>
<pre class="literal-block">
ModuleName:EventHandlerClass
</pre>
<p>The <tt class="literal"><span class="pre">ModuleName</span></tt> specifies a Python module that contains the
<tt class="literal"><span class="pre">EventHandlerClass</span></tt>.  <tt class="literal"><span class="pre">ModuleName</span></tt> must be located in the
directory specified by the <tt class="literal"><span class="pre">&lt;handlerDirectory&gt;</span></tt> element at the
beginning of the configuration.  If <tt class="literal"><span class="pre">EventHandlerClass</span></tt> is <em>not</em>
found in <tt class="literal"><span class="pre">ModuleName</span></tt>, <tt class="literal"><span class="pre">EventHandler</span></tt> is appended to the
<tt class="literal"><span class="pre">EventHandlerClass</span></tt>.  For example, given the following custom event
handler specification:</p>
<pre class="literal-block">
CustomEventHandlers:TelnetHost
</pre>
<p>Either <tt class="literal"><span class="pre">TelnetHost</span></tt> or <tt class="literal"><span class="pre">TelnetHostEventHandler</span></tt> must be defined in
the Python module <tt class="literal"><span class="pre">/home/kaz/src/CustomEventHandlers.py</span></tt>.  This
concludes the XML configuration required for our custom event handler.
In the next section, we'll explore the actual Python class that
implements the event handler functionality.</p>
</div>
<div class="section" id="event-handler-implementation">
<h1><a name="event-handler-implementation">Event Handler Implementation</a></h1>
<p>With the XML configuration completed, all that is left is the
implementation of the event handler.  Writing your own event handler
is a very easy.  There are a few things you should be aware of before
starting.  First, all event handlers must subclass the base event
handler <tt class="literal"><span class="pre">com.kazmier.event.Event.EventHandler</span></tt>.  For example, here
are the first few lines of our event handler:</p>
<pre class="literal-block">
from com.kazmier.event.Event import EventHandler

class TelnetHostEventHandler(EventHandler):
    ...
</pre>
<p>In addition, there several other topics that deserve further
attention.  They are the initialization, execution, and access to
event data including timestamps, the line that caused the match, as
well as any saved group data from the regular expression.  Each of
these topics is covered in the following sections.</p>
<div class="section" id="initialization">
<h2><a name="initialization">Initialization</a></h2>
<p>As with all Python classes, you may choose to pass arguments to your
constructor when creating an instance of your event handler.  This is
done via the standard method called <tt class="literal"><span class="pre">__init__</span></tt> in Python.  In order
to make the <tt class="literal"><span class="pre">TelnetHost</span></tt> event handler generic, parameters such as
host, port, username, password, and the command to execute should be
passed at creation time:</p>
<pre class="literal-block">
class TelnetHostEventHandler(EventHandler):
    def __init__(self, host, port=23, user, password, command):
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.command = command
</pre>
<p>By storing these values, the event handler can use them later when
processing an event (the result of a matched line in a log).  The
above is sufficient if one is only ever going to use the LogWrap API
directly.  However, this tutorial is using the <tt class="literal"><span class="pre">logwrap</span></tt> script and
XML configuration file.  In this mode of operation, the user does not
invoke this constructor and thus cannot pass values to it.</p>
<p>It turns out that the LogWrap framework has a little bit of magic
baked in to facilitate the passing of values to an event handler's
constructor when using the XML configuration file.  Users can specify
values by setting XML attributes to the <tt class="literal"><span class="pre">&lt;handler&gt;</span></tt> element in the
configuration file.  Each attribute's name must be the same as the
name of the argument in the constructor.  For example:</p>
<pre class="literal-block">
&lt;handler type=&quot;CustomEventHandlers:TelnetHost&quot;
         host=&quot;\1&quot;
         user=&quot;kaz&quot;
         password=&quot;blahblah&quot;
         command=&quot;df&quot;/&gt;
</pre>
<p>The above XML sets four attributes (not counting the <tt class="literal"><span class="pre">type</span></tt>
attribute which you must set to specify the event handler).  Each of
the attribute names corresponds to the argument names in the
constructor.  Note: if an value is not passed (such as the <tt class="literal"><span class="pre">port</span></tt>),
it must have a default value set in the constructor (23 in this case).
Sometimes passing values via XML attributes is not sufficient because
you have multiline data to pass or characters that cannot appear in an
XML attribute's value.  In this case, an alternative syntax is
provided:</p>
<pre class="literal-block">
&lt;handler type=&quot;CustomEventHandlers:TelnetHost&quot;&gt;
  &lt;host&gt;\1&lt;/host&gt;
  &lt;user&gt;kaz&lt;/user&gt;
  &lt;password&gt;blahblah&lt;/password&gt;
  &lt;command&gt;df&lt;/command&gt;
&lt;/handler&gt;
</pre>
<p>Instead of passing the values as attributes, you can pass the values
as the text of a child element whose name corresponds to the arguments
in the constructor.  When using this notation, you can also use CDATA
blocks if desired.</p>
<p>Now that you've seen the magic that the LogWrap framework provides,
there is one caveat the programmer must remember: <em>If arguments are
passed to an event handler's constructor via the XML configuration
file, they are passed as strings.</em> As such, you must handle the
conversion of these strings to other data types as appropriate.  In
our simple event handler, none of the values passed are non-string
objects, however, if we were to pass a port number via an XML
attribute, it would be passed as a string.  Thus, we should handle the
conversion of this string to an integer in our constructor:</p>
<pre class="literal-block">
class TelnetHostEventHandler(EventHandler):
    def __init__(self, host, port=23, user, password, command):
        self.host = host
        self.port = int(port) # Convert to integer if not already
        self.user = user
        self.password = password
        self.command = command
</pre>
<p>You've now seen how an event handler is instantiated via the XML
configuration file.  The next section provides the details on the
execution of the event handler.</p>
</div>
<div class="section" id="execution">
<h2><a name="execution">Execution</a></h2>
<p>A little background on the LogWrap event framework is first needed
before proceeding with the implementation of the custom event handler.
Included in the distribution of the LogWrap framework is a separate
event framework.  The event framework consists of two threads
interconnected by an event queue.  The first thread is responsible for
the generation of events and the placement of these events into the
event queue.  The second thread is responsible for the dequeuing and
processing of events.  It is the latter thread that invokes all of the
event handlers.  See the following diagram:</p>
<pre class="literal-block">
                        |
                        |
                 +-------------+
Generator -----&gt; | Event Queue | -----&gt; Processor
                 +-------------+
                        |
              Thread 1  |  Thread 2
</pre>
<p>The fact that event processing occurs in a separate thread is
important because your custom event handler does not have to be
&quot;spawned&quot; off in another process or thread to avoid losing events.
Event generation and queuing are not affected if your event handler
takes a few seconds to execute because the event queue acts as a
buffer.  This simplifies the coding of event handlers.</p>
<blockquote>
On a side note, if your event handler is very slow, and you have
an excessive amount of events being generated for a constant time,
your queue will grow and grow and grow.  At that point, you need
to investigate the use of the frequency suppression event handlers
included with the LogWrap framework.  However, with that said, the
most common scenario is that the queue will fluctuate over time
growing larger when bursts of events arrive and emptying when
there is little event generation taking place.</blockquote>
<p>All event handlers are invoked by the EventProcessor which passes the
<tt class="literal"><span class="pre">Event</span></tt> as the only argument to the <tt class="literal"><span class="pre">process_event</span></tt> method of the
event handler.  The following is a simple event handler that does
nothing other than print the <tt class="literal"><span class="pre">Event</span></tt> object to the screen:</p>
<pre class="literal-block">
class SimpleEventHandler(EventHandler):
    def process_event(self, event):
        print &quot;event =&quot;, event
        return 1
</pre>
<p>It is important to note that this event handler returns <tt class="literal"><span class="pre">1</span></tt> which
indicates that subsequent handlers should be invoked if this event
handler was part of a event handler chain (as described earlier).  If
you want to stop the execution of the chain, return a value of <tt class="literal"><span class="pre">0</span></tt>
instead.</p>
<p>In the next section, we will explore the <tt class="literal"><span class="pre">Event</span></tt> object and all of
the data it can provide to us when we write our implementation of our
event handler.</p>
</div>
<div class="section" id="event-data">
<h2><a name="event-data">Event Data</a></h2>
<p>An event handler would not be very useful unless it had access to
context information related to the event in question.  Specifically,
the timestamp, the originator of the event, the original line that
triggered the event in the log file, as well as any grouped data
specified in the regular expression that was used to match the event.
Fortunately, all of the above are available to the programmer via the
<tt class="literal"><span class="pre">Event</span></tt> object when writing an event handler.  The following event
handler illustrates how one can access this information:</p>
<pre class="literal-block">
class ExamineEventHandler(EventHandler):
    def process_event(self, event):
        print &quot;------------------&quot;
        print &quot;Creation Time:    &quot;, time.ctime(event.time)
        print &quot;Originator's Name:&quot;, event.originator
        print &quot;Original Line:    &quot;, event.data.line,
        print &quot;Match Object:     &quot;, event.data.match.groups()
        return 1
</pre>
<p>A more verbose description of each of the above is provided below:</p>
<dl>
<dt>event.time</dt>
<dd>Contains the time when this event was created.  The value is stored
as a number of seconds since Epoch.</dd>
<dt>event.originator</dt>
<dd>Contains a reference to the originator of this event.  In the event
framework, this refers to an <tt class="literal"><span class="pre">EventGenerator</span></tt>.  Within the LogWrap
context, this object refers to the <tt class="literal"><span class="pre">LogEncapsulator</span></tt> (a subclass
of an <tt class="literal"><span class="pre">EventGenerator</span></tt>).  The string representation of the
<tt class="literal"><span class="pre">LogEncapsulator</span></tt> is simply its name.  This is the same name that
was specified in the <tt class="literal"><span class="pre">&lt;logEncapsulator&gt;</span></tt> element.</dd>
<dt>event.data</dt>
<dd>Contains a reference to a piece of arbitrary data that has been
associated with this event.  The <tt class="literal"><span class="pre">EventGenerator</span></tt> specifies the
contents of this variable.  In this context, the <tt class="literal"><span class="pre">LogEncapsulator</span></tt>
stores a reference to a <tt class="literal"><span class="pre">LogMatch</span></tt> object.</dd>
<dt>event.data.line</dt>
<dd>Contains the original line that generated the event.  This value is
stored as part of the <tt class="literal"><span class="pre">LogMatch</span></tt> object.</dd>
<dt>event.data.match</dt>
<dd>Contains a <tt class="literal"><span class="pre">MatchObject</span></tt> (from the Python <tt class="literal"><span class="pre">re</span></tt> module) which can
be queried for items that were grouped in the regular expression.
This enables the event handler to gain access to parts of the
original log message.  In this tutorial, this will be used to access
the IP address of the host.</dd>
</dl>
</div>
<div class="section" id="telnethost-implementation">
<h2><a name="telnethost-implementation">TelnetHost Implementation</a></h2>
<p>You are now armed with all of the necessary information to write the
full implementation of the <tt class="literal"><span class="pre">TelnetHost</span></tt> custom event handler.  The
contents of following script must be located in a file called
<tt class="literal"><span class="pre">/home/kaz/src/CustomEventHandlers.py</span></tt> (unless you have changed the
value of the <tt class="literal"><span class="pre">&lt;handlerDirectory&gt;</span></tt> element in the XML configuration
file):</p>
<pre class="literal-block">
from com.kazmier.event.Event import EventHandler

class TelnetHostEventHandler(EventHandler):  # Must extend EventHandler

    # The construct defines the args we expect in the XML file,
    # you'll notice for each arg here, there is a corresponding XML
    # attribute defined in the config file.
    def __init__(self, host, port=23, user, password, command):
        self.host = host
        self.port = int(port) # Handle the conversion from string to int
        self.user = user
        self.password = password
        self.command = command

    # This is the method that is called when the event handler is
    # invoked.  It is passed a reference to the event itself which
    # lets us do some nifty things like get at those parts of the
    # regular expression that we grouped using the parens.
    def process_event(self, event):
        import telnetlib

        # And here is the magic that converts &quot;\1&quot; into the IP
        # address that was sent to the log file.  This simply uses
        # the MatchObject from the re library to do the expansion.
        telnet = telnetlib.Telnet(event.data.match.expand(self.host))

        # Login to the host
        telnet.read_until(&quot;login: &quot;)
        telnet.write(self.user + &quot;\n&quot;)
        telnet.read_until(&quot;Password: &quot;)
        telnet.write(self.password + &quot;\n&quot;)

        # Run the command that was specified in the XML configuration  
        telnet.write(self.command + &quot;\n&quot;)
        telnet.write(&quot;exit\n&quot;)
        output = telnet.read_all()
        telnet.close()

        # We'll probably want to do something other than just
        # printing the output to the screen, but this will suffice
        # for this tutorial.
        print output

        # Its important to return 1 if you want to permit other
        # event handlers defined in the configuration to run.  If
        # you don't, you effectively stop the event handler chain.
        # This is how the frequency suppression handler works.
        return 1
</pre>
<p>You can test this example with the following commands:</p>
<pre class="literal-block">
$ touch /var/log/app.log   # Create the file if it doesn't exit
$ logwrap path_to_xml_configuration_file
</pre>
<p>Then, in another shell (or window):</p>
<pre class="literal-block">
$ echo &quot;WARNING: Disk Space Low on 10.11.12.13&quot; &gt;&gt; /var/log/app.log
</pre>
<p>At this point, in the first window, you should see the output of the
<tt class="literal"><span class="pre">df</span></tt> command for the host <tt class="literal"><span class="pre">10.11.12.13</span></tt>.</p>
<p>Congratulations!  You've successfully written your own custom event
handler.  Custom event handlers are useful if you are seeking
functionality that isn't provided by an event handler included in the
LogWrap distribution.</p>
</div>
</div>
</div>
</body>
</html>
